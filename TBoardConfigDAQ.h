#ifndef BOARDCONFIGDAQ_H
#define BOARDCONFIGDAQ_H

#include "TBoardConfig.h"

const int LIMIT_DIGITAL = 300; //300;
const int LIMIT_IO      =  50; // 10, depreciated but leave in to write the register to some defined value
const int LIMIT_ANALOG  = 300; //100;

const int AUTOSHTDWN_TIME    = 10;      // time until enabling of auto shutdown
const int CLOCK_ENABLE_TIME  = 12;      // time until clock is enabled
const int SIGNAL_ENABLE_TIME = 12;      // time until signals are enabled
const int DRST_TIME          = 13;      // time until drst is deasserted



//************************************************************
// TBoardConfigDAQ: config for Cagliari DAQboard 
//************************************************************

class TBoardConfigDAQ : public TBoardConfig {
 private:


  // config related to firmware modules
  //----------------------------------------------------------
  //
  ////---- ADC module

  // ADC config reg 0
  int fCurrentLimitDigital;   // 11: 0; threshold current for digital supply 
  int fCurrentLimitIo;        // 23:12; threshold current for digital io supply
  bool fAutoShutdownEnable;   //    24; 0: disable, 1: enable
  bool fLDOEnable;            //    25; 0: disable, 1: enable; LDOAutoShutOff has no effect if this it is not set
  bool fADCEnable;            //    26; 0: disable, 1: enable; enables current/voltage sampling
  bool fADCSelfStop;          //    27;
  bool fDisableTstmpReset;    //    28; if set, disables the reset of the timestamp counter with the strobe; default is 0
  bool fPktBasedROEnable;     //    29; enables/disables packet based readout for the ADCs; default is 0.

  // ADC config reg 1
  int fCurrentLimitAnalogue;  // 11: 0; threshold current for analogue supply 

  // ADC config reg 2
  uint32_t fAutoShutOffDelay; // 19: 0; delay with a granularity of 12.5ns
  int fADCDownSamplingFact;   // 31:20; factor for downscaling ADC sampling rate


  ////---- READOUT module
  
  // Event builder config reg

  int fMaxDiffTriggers;       //  3: 0; maximum difference between the number of triggers sent and the number of events recorded before the busy signal to the TLU is set high.
  bool fSamplingEdgeSelect;   //     4; edge of clock on which the chip event data is sampled in the FPGA event builder. 0: positive edge, 1: negative edge (for pA1 inverted..)
  bool fPackedBasedROEnable;  //     5; 0: disable, 1: enable
  bool fDDREnable;            //     6; 0: disable, 1: enable 
  int fDataPortSelect;        //  8: 7; 01: serial port, 10: parallel port
  int fFPGAEmulationMode;     // 10: 9; 00: FPGA is bus master, chip is in IB or OB master mode (default)
                              //        01: the FPGA emulates an OB master, chip is slave;    !! not working with pA3 and later versions
                              //        10: the FPGA emulates an OB slave, chip is OB master; !! not working with pA3 and later versions

  
  ////---- TRIGGER module
  
  // Busy configuration register
  int fBusyDuration;          // 31: 0; minimum duration of the busy generated by the trigger sequencer
    
  // Trigger configuration register
  int fNTriggers;             // 15: 0; number of triggers sent to chip; if set to 0, continuous triggering will be performed; TODO: feature ever used?
  int fTriggerMode;           // 18:16; 0: disabled, 
                              //        1: auto trigger mode: system triggers the chip automatically after a start trigger command
                              //        2: external trigger mode: system triggers the chip on external trigger after a start trigger command
  int fStrobeDuration;        // 26:19; strobe duration with 25 ns granularity; depreciated

  // Strobe delay register
  uint32_t fStrobeDelay;      // 31: 0; delay between the external trigger and the strobe sent to chip; with 25 ns granularity

  // Busy override register
  bool fBusyOverride;         //     0; 0: TLU busy is overridden, busy to TLU is kept high; 1: TLU busy is not overridden


  ////---- CMU module
 
  // CMU config register 
  bool      fManchesterDisable;     //     0; 0: enable manchester encoding; 1: disable
  bool      fSamplingEdgeSelectCMU; //     1; edge of the FPGA clock on which the CMU data is sampled in the FPGA CMU receiver; 0: positive edge; 1: negative edge
  bool      fInvertCMUBus;          //     2; 0: bus not inverted; 1: bus inverted
  bool      fChipMaster;            //     3; 0: chip is master; 1: chip is slave

  
  ////---- RESET module

  // PULSE DRST PRST duration reg
  int fPRSTDuration;            //  7: 0; depreciated
  int fDRSTDuration;            // 15: 8; TODO: should rather be done via opcode?
  int fPULSEDuration;           // 31:16; depreciated

  // Power up sequencer delay reg
  int fAutoShutdownTime;        //  7: 0; delay with 51.2 us granularity from the LDOs ON to the start of the auto shutdown mechanism
  int fClockEnableTime;         // 15: 8; delay with 51.2 us granularity from the LDOs ON to the enable of the pALPIDEfs clock 
  int fSignalEnableTime;        // 23:16; delay with 51.2 us granularity from the LDOs ON to the enable of the pALPIDEfs input signals (except pCLK and DRST)
  int fDrstTime;                // 32:24; delay with 51.2 us granularity from the LDOs ON to the deassertion of DRST signal

  // PULSE STROBE delay sequence reg
  int fPulseDelay;              // 15: 0; delay between strobe and pulse
  int fStrobePulseSeq;          // 17:16; 0: pulse is generated after write access to pulse command register
                                //        1: strobe - delay - pulse; pulse is generated after a delay with respect to the strobe
                                //        2: pulse - delay - strobe; pulse is generated after a write access to pulse command register and a delay is enabled for a generated strobe; 
                                //                                   this strobe goes to the trigger sequencer module in external trigger mode

  // PowerOnReset disable reg
  bool fPOREnable;              //     0; 0: enable POR; 1: disable


  ////---- ID module


  ////---- SOFTRESET module
  
  // Software reset duration register
  int fSoftResetDuration;       //  7: 0; software reset duration

  //----------------------------------------------------------



 protected:

 public:
  TBoardConfigDAQ(const char *fName = 0, int boardIndex = 0);
  int GetBoardType() {return 0;};

  int GetCurrentLimitDigital()   {return fCurrentLimitDigital;};
  int GetCurrentLimitIo()        {return fCurrentLimitIo;};
  int GetCurrentLimitAnalogue()  {return fCurrentLimitDigital;};

  int GetAutoShutdownTime() {return fAutoShutdownTime;};
  int GetClockEnableTime()  {return fClockEnableTime;};
  int GetSignalEnableTime() {return fSignalEnableTime;};
  int GetDrstTime()         {return fDrstTime;};


};

//************************************************************

#endif   /* BOARDCONFIGDAQ_H */
